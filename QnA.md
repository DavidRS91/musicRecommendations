Describe in a high level the solution you have in mind
> My idea for recommending music to users is based on calculating which tags are most prominent in the songs that they have listened to in the past, as well as the tags that are most prominent in the listens of the users they follow. I have designed a solution that will return the five songs whose tags occur most frequently (based on the above), excluding songs that the user has already heard (to encourage discovering new music). 

What other data could you use to improve recommendations?
>Two pieces of data that could help improve accuracy are like/dislike and artist. With the current solution, there is an inherent assumption that users like all music they listen to, which is likely not the case. like/dislike would allow an algorithm to put more weight behind songs a user has liked, and avoid songs similar to those that a user has disliked. Artists are important because users likely have favourite artists, and tracking artists would allow the algorithm to suggest unheard music from an artist the user frequently listens to. Additional considerations include date (to recommend seasonally appropriate music), understanding how users interact with each other (are some users more closely related than others?), and when the user listened to music (the algorithm would likely be more effective if it more heavily valued songs that were recently listened to).

Assume a more real world situation where you could have more data you described above, and more time to implement, could you think of a possibly more efficient way to recommend?
> Yes, depending on the interpretation of "more efficient". 
>
>If more efficient means a solution that provides recommendations that the user is more likely to enjoy, then I would suggest giving a positive score to the tags that most frequently occur in a songs that a user has liked, as well as valuing the artists that the user listens to and likes the most. Conversely, user dislikes can be used to avoid certain genres and artists. Finally, when evaluating the preferences of followed users, the improved algorithm would weight the importance of a followed user's preferences based on how much the user requesting recommendations interacts with them (eg. visits their profile, messages them, likes their posts, etc.).  
>
>If more efficient means faster code, a user document could store metadata about the users recent listens/follows to give an approximation of their recent taste in music. When recommendations are required for a user, that metadata could save an algorithm from having to search all of a user's previous listens and all of the users they follow. It could also filter out songs which are not likely to be recommended and avoid scoring or "ranking" them.

Assume you have more than one implementation of recommendations, how could you test which one is more effective using data generated by user actions?
>You could keep track of the average percentage of recommendations that are listened to by users in each implementation, as well as how many times the recommendation is listened to by each user in each implementation. Additionally, if there was like/dislike functionality, you could use that to track the users' sentiments about songs they had been recommended.

--

How long did this assignment take?
> Close to three days, though I misunderstood some instructions, causing me to spend time on building a seed script that was not required. I anticipate it would have taken 2.5 days without the seed script.

Where would be the bottlenecks of this solution you have implemented?
>The current solution loops through all songs listened to by the user, all songs listened to by the users a user follows, and all songs in the database. As more songs are added to the db, more songs are listened to, and more users follow eachother, the time taken to recommend a song will increase. The main bottleneck lies in looping through all songs, especially if the database contains an amount of content similar to iTunes or spotify. A user that listens to lots of music and follows many users will also slow down the recommendation algorithm.

What was the hardest part?
> I found two facets of this assignment particularly challenging. First, trying to build a solution with technologies I haven't used before (MongoDB & Koa), required me to spend time reading lots of docs and spend plenty of time troubleshooting; frequently running into errors made it hard to keep focus on the task at hand. Second, I'm used to have the benefit of consulting more experienced developers when I get stuck - it was equally rewarding and frustrating to have to solve all the problems I encountered on my own.

Did you learn something new?
> Yes, as mentioned above, I have never worked with Koa or MongoDB prior to this assignment, so it was a great opportunity to familiarize myself with these technologies. In fact, it was my first time dealing with a NoSQL database and this project gave me a much clearer understanding of how NoSQL databases work.

Do you feel that your skills were well tested?
> Yes, I feel like I have been able to demonstrate my ability to work independently, learn new technologies, and build logical code to solve problems. 
